#!/bin/bash
# Hyprland Display-Aware Workspace Command Wrapper (Using Display Names)
#
# Description:
# This script intelligently generates a static Hyprland config file for workspace
# bindings and only rewrites it when your monitor configuration changes.
# This avoids slow startup times caused by running `hyprctl` commands repeatedly.
#
# IMPORTANT: This version uses display names/models instead of port names to
# maintain consistent ordering even when ports change due to reconnection.
#
# The generated config file can be sourced in your main hyprland.conf.
# e.g., source = ~/.config/hypr/scripts/ssw.conf
#
# It then calculates the target workspace based on the monitor where the cursor
# is located (not necessarily the focused window's monitor), allowing for
# consistent workspace management that keeps you on the same physical monitor.
#
# Formula: target_workspace = input_workspace + (cursor_monitor_id - 1) * 10
#
# Usage: ./hypr_workspace.sh <command> <workspace_number>

# --- Initial Validation ---
if [ $# -ne 2 ]; then
  echo "Usage: $0 <command> <workspace_number>"
  echo "Commands: workspace, movetoworkspace, movetoworkspacesilent"
  echo "workspace_number should be 1-10"
  exit 1
fi

command=$1
input_workspace=$2

# Validate input workspace is a number between 1 and 10
if ! [[ "$input_workspace" =~ ^[1-9]$|^10$ ]]; then
  echo "Error: workspace_number must be between 1 and 10."
  exit 1
fi

# Validate command is one of the allowed Hyprland dispatches
case "$command" in
workspace | movetoworkspace | movetoworkspacesilent) ;;
*)
  echo "Error: Invalid command. Use 'workspace', 'movetoworkspace', or 'movetoworkspacesilent'."
  exit 1
  ;;
esac

# --- Configuration File Setup ---
# The script will generate the workspace config at this location.
# Using $HOME ensures the tilde `~` is expanded correctly.
CONF_FILE="$HOME/.config/hypr/scripts/ssw.conf"
CONF_DIR=$(dirname "$CONF_FILE")

# --- Monitor Detection and Conditional Config Generation ---

# Check for jq dependency, which is required for reliable JSON parsing
if ! command -v jq >/dev/null 2>&1; then
  echo "Error: 'jq' is not installed. Please install it to use this script."
  exit 1
fi

# Get monitor information with both port names and display names
# We'll create a mapping of display names to port names and use display names for ordering
mapfile -t monitor_data < <(hyprctl monitors -j | jq -r '.[] | "\(.description)|\(.name)"')

# Extract display information
declare -a display_names
declare -a port_names
declare -A display_to_port

for data in "${monitor_data[@]}"; do
  # Split on the pipe character
  display_name="${data%|*}"
  port_name="${data#*|}"

  # Clean up display name (remove extra spaces, make it more consistent)
  display_name=$(echo "$display_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

  # If display name is empty or just whitespace, fall back to port name
  if [[ -z "$display_name" || "$display_name" =~ ^[[:space:]]*$ ]]; then
    display_name="$port_name"
  fi

  display_names+=("$display_name")
  port_names+=("$port_name")
  display_to_port["$display_name"]="$port_name"
done

# Sort display names to ensure consistent ordering regardless of connection order
# This is the key change - we sort by display name to maintain order
IFS=$'\n' sorted_display_names=($(sort <<<"${display_names[*]}"))
unset IFS

# Create a single string representation of the current monitor setup for easy comparison.
current_monitor_config=$(printf "%s " "${sorted_display_names[@]}")

# Read the monitor configuration from the header of the existing config file.
previous_monitor_config=""
if [ -f "$CONF_FILE" ]; then
  # Extracts the monitor list from a line like "# DISPLAYS: Display1 Display2"
  previous_monitor_config=$(grep '^# DISPLAYS:' "$CONF_FILE" | sed 's/# DISPLAYS: //')
fi

# Compare current config with the cached one. If they differ, regenerate the config file.
if [ "$current_monitor_config" != "$previous_monitor_config" ]; then
  echo "Debug: Monitor configuration changed. Regenerating config file at $CONF_FILE..."

  # Ensure the config directory exists
  mkdir -p "$CONF_DIR"

  # Write the new config file from scratch
  {
    echo "# DISPLAYS: $current_monitor_config"
    echo "# This file is auto-generated by hypr_workspace.sh. Do not edit manually."
    echo "# Generated on: $(date)"
    echo ""

    # This section generates the workspace-to-monitor binding rules.
    # We use sorted display names for consistent ordering
    for i in "${!sorted_display_names[@]}"; do
      monitor_id_for_binding=$((i + 1))
      display_name_for_binding="${sorted_display_names[$i]}"
      port_name_for_binding="${display_to_port[$display_name_for_binding]}"

      echo "# Bindings for Monitor $monitor_id_for_binding: $display_name_for_binding (Port: $port_name_for_binding)"
      # Assign 10 workspaces to the current monitor
      for j in {1..10}; do
        workspace_to_bind=$(((monitor_id_for_binding - 1) * 10 + j))
        # Use port name for the actual binding since that's what Hyprland expects
        echo "workspace = $workspace_to_bind,monitor:$port_name_for_binding,persistent:true"
      done
      echo ""
    done
  } >"$CONF_FILE"

  echo "Debug: Config file regenerated. Please reload Hyprland for changes to take effect."
fi

# --- Monitor Detection (Using Focused Monitor) ---

# Get the currently focused monitor's information
focused_monitor_info=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true) | "\(.description)|\(.name)"')

# If no monitor is actively focused (can happen in some edge cases),
# fall back to finding the monitor that contains the active window.
if [ -z "$focused_monitor_info" ]; then
  echo "Debug: No focused monitor detected, checking active window's monitor..."
  focused_port_name=$(hyprctl activewindow -j | jq -r '.monitor')
  # Find the display name for this port
  focused_monitor_info=$(hyprctl monitors -j | jq -r ".[] | select(.name == \"$focused_port_name\") | \"\(.description)|\(.name)\"")
fi

# Extract display name from focused monitor info
target_display_name="${focused_monitor_info%|*}"
target_display_name=$(echo "$target_display_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

# If display name is empty, use port name as fallback
if [[ -z "$target_display_name" || "$target_display_name" =~ ^[[:space:]]*$ ]]; then
  target_display_name="${focused_monitor_info#*|}"
fi

# Find the sequential ID (1-based index) of the target monitor from our sorted array.
monitor_id=0
for i in "${!sorted_display_names[@]}"; do
  if [[ "${sorted_display_names[$i]}" == "$target_display_name" ]]; then
    # Bash arrays are 0-indexed, so add 1 for a 1-based ID (1, 2, 3...).
    monitor_id=$((i + 1))
    break
  fi
done

# If we couldn't find the monitor for some reason, exit with an error.
if [ "$monitor_id" -eq 0 ]; then
  echo "Error: Could not determine a valid ID for the target monitor display ('$target_display_name')."
  echo "Available displays found (sorted): ${sorted_display_names[*]}"
  exit 1
fi

# --- Workspace Calculation and Execution ---

# Calculate the target workspace using the scalable formula.
target_workspace=$((input_workspace + (monitor_id - 1) * 10))

echo "Debug: Target Display: '$target_display_name' (ID: $monitor_id)"
echo "Debug: Input: $input_workspace -> Target: $target_workspace"

# Execute the final command using hyprctl.
hyprctl dispatch "$command" "$target_workspace"

echo "Executed: hyprctl dispatch $command $target_workspace"
